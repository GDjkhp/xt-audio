/**
 * @mainpage XT-Audio
 *
 * @section abstractions Core abstractions
 *
 * <b>Systems and services</b>
 *
 * An audio service is an implementation of the XtService API on a specific backend.
 * Supported backends include DirectSound, WASAPI and ASIO on windows, and PulseAudio,
 * ALSA and JACK on linux. Services are used primarily to query and open available audio devices.
 *
 * <b>Devices</b>
 *
 * An audio device is an implementation of the XtDevice API on a specific backend.
 * Depending on the backend type, devices may directly correspond to physical audio
 * cards (ASIO, ALSA hw, WASAPI exclusive), system mixers on top of such cards
 * (ALSA plughw, WASAPI shared, DirectSound), or sound services which allow user-
 * defined routing from application input/output to physical or virtual devices
 * (JACK and PulseAudio). The device API may be used to query format support and
 * buffer sizes, and to create audio streams.
 *
 * <b>Streams</b>
 *
 * An audio stream is an implementation of the XtStream API on a specific backend.
 * Each stream is tied to an application-defined callback function (XtStreamCallback)
 * which is called whenever the stream is ready to deliver or receive more data.
 * The XtStream API can be used to control (start/stop) audio streams and to query
 * latencies and buffer sizes.
 *
 * @section usage Basic usage
 *
 * An application must first initialize the library using XtAudioInit.
 * From there, it can select an audio service, query for available devices,
 * and open streams on those devices. The choice of backend (system) greatly
 * affects the way audio is streamed in terms of latency, supported formats
 * and whether the application takes system-wide exclusive control of a device.
 * If you know exactly what your application needs, use XtAudioGetServiceBySetup
 * or XtAudioGetServiceBySystem to select a backend with specific characteristics.
 * Otherwise it's probably best to let the end-user pick the system and device to use.
 *
 * Streaming audio with XT-Audio involves at least these steps:
 * 1. Initialize (XtAudioInit)
 * 2. Select service (XtAudioGetServiceByIndex/XtAudioGetServiceBySetup/XtAudioGetServiceBySystem)
 * 3. Select device (XtServiceOpenDevice/XtServiceOpenDefaultDevice)
 * 4. Test format and buffer size support (XtDeviceSupportsFormat/XtDeviceGetBuffer)
 * 5. Open a stream (XtDeviceOpenStream/XtServiceAggregateStream)
 * 6. Start running (XtStreamStart)
 * 7. Stop running (XtStreamStop)
 * 8. Cleanup stream (XtStreamDestroy)
 * 9. Cleanup device (XtDeviceDestroy)
 * 10. Cleanup library (XtAudioTerminate)
 *
 * @section langdiffs API differences between languages
 *
 * <b>Error handling</b>
 *
 * The core API uses error codes exclusively. C++, Java and C# API's use only exceptions.
 *
 * <b>String handling</b>
 *
 * In the C and C++ API's, all strings are encoded as UTF-8. In the C# and Java API's strings use the built-in string type.
 *
 * <b>Resource handling</b>
 *
 * In all language API's there are 3 resources that must be explicitly managed: devices, streams, and the library itself.
 * For C, this means XtDeviceDestroy/XtStreamDestroy/XtAudioTerminate. For C++ everything is handled using RAII,
 * the XtAudio constructor calls XtAudioInit and destructor calls XtAudioTerminate. Devices and streams are handled
 * using std::unique_ptrs. For Java each resource implements Closeable, for C# IDisposable. Except for the C API
 * these are the only resources the application needs to be concerned about. For C, it is documented whether return
 * values and output parameters should be explicitly cleaned up using XtAudioFree().
 *
 * <b>Audio buffers</b>
 *
 * When using interleaved access, the data passed to the callback is a pointer to a single array of samples,
 * and the audio buffer contains alternating samples for each channel, e.g. [LRLRLR] for a stereo stream.
 * When using non-interleaved access, there is one audio buffer for each channel, and the data passed to the
 * callback is a pointer to an array of pointers each pointing to the audio buffer for a single channel,
 * e.g. [LLL][RRR] for a stereo stream.
 *
 * The input/output buffers passed to XtStreamCallback should be cast to the appropriate type before usage.
 * For C and C++ (and Java and C# in raw mode) this means unsigned char*, short*, int* or float* for interleaved
 * buffers, or unsigned char**, short**, int** or float** for non-interleaved buffers. For Java and C# this
 * means byte[], short[], int[] or float[] for interleaved buffers or byte[][], short[][], int[][] or float[][]
 * for non-interleaved buffers. Applications should never write to the input buffer.
 *
 * <b>Stream aggregation</b>
 *
 * XT-Audio allows an application to open an audio stream on more than one device. This is primarily intended
 * to emulate full-duplex operation on systems which don't natively support it, but may be used to aggregate
 * any number of input, output and/or full-duplex streams. The resulting stream's channel count will be equal
 * to the total number of channels requested for each of the underlying streams. Aggregate streams introduce
 * an intermediate buffer to keep underlying streams in sync, and as such (and unlike anything else in XT-Audio)
 * they actually add latency to a running stream. Aggregate streams are created using XtServiceAggregateStream
 * instead of XtDeviceOpenStream. Other than that, the stream interface (including callback functions) is 
 * exactly the same as for regular audio streams.
 */

 /**
 * @file XtAudio.h
 * @brief The core XT-Audio interface.
 */

/**
 * @defgroup library Generic interface
 * @brief Common datatypes.
 *
 * Contains definitions of common datatypes.
 */

/**
 * @defgroup audio Bootstrapping interface
 * @brief Bootstrapping and service selection
 *
 * Contains functions to initialize the library, choosing between
 * audio services and seting up logging and error handling.
 */

/**
 * @defgroup service Service interface
 * @brief Service capabilities and device enumeration.
 *
 * Contains functions to query audio services for
 * capabilities and opening default and specific devices.
 */

/**
 * @defgroup device Device interface
 * @brief Device queries and stream creation.
 *
 * Contains functions to query audio devices for
 * capabilities and opening audio streams.
 */

/**
 * @defgroup stream Stream interface
 * @brief Stream queries and operation.
 *
 * Contains functions to control (start/stop) audio streams
 * and querying running audio streams for buffer size and latencies.
 */

/**
 * @defgroup stream Stream interface
 * @brief Stream queries and operation.
 *
 * Contains functions to control (start/stop) audio streams
 * and querying running audio streams for buffer size and latencies.
 */

/**
 * @fn XtBool XtAudioIsWin32(void)
 * @brief Indicates whether XT-Audio is running on Windows (true) or Linux (false).
 * @return true if running on windows, false if running on linux.
 *
 * The only time this value is useful is when an application wants to work with a specific service (XtAudioGetServiceBySystem).
 *
 * This function may be called from any thread.
 */

/**
 * @fn void XtAudioTerminate(void)
 * @brief Terminates the XT-Audio library.
 *
 * It is an error to terminate the library when any streams or devices are still open.
 *
 * This function may only be called from the main thread.
 */

/**
 * @fn void XtAudioFree(void* ptr)
 * @brief Standard free() wrapper.
 * @param ptr the memory to free.
 *
 * All functions which allocate memory that must be free()d by the application indicate so in the documentation.
 * It is ok to free NULL.
 *
 * This function may be called from any thread.
 */

/**
 * @fn int32_t XtAudioGetVersionMajor(void)
 * @brief Get library major version.
 * @return library major version.
 *
 * This function may be called from any thread.
 */

/**
 * @fn int32_t XtAudioGetVersionMinor(void)
 * @brief Get library minor version.
 * @return library minor version.
 *
 * This function may be called from any thread.
 */

/**
 * @fn int32_t XtAudioGetServiceCount(void)
 * @brief Get number of available services on the current platform.
 * @return number of available services.
 *
 * This function may be called from any thread.
 * @see XtAudioGetServiceByIndex
 */

/**
 * @fn const XtService* XtAudioGetServiceByIndex(int32_t index)
 * @brief Get service by index.
 * @return an audio service.
 * @param index the index, from 0 to XtAudioGetServiceCount (exclusive).
 *
 * This function may be called from any thread.
 * @see XtAudioGetServiceCount
 */

/**
 * @fn const XtService* XtAudioGetServiceBySetup(XtSetup setup)
 * @brief Get service by setup.
 * @return an audio service, or NULL if XT-Audio was compiled without support for the given setup.
 * @param setup the desired setup type.
 *
 * This function may be called from any thread.
 */

/**
 * @fn const XtService* XtAudioGetServiceBySystem(XtSystem system)
 * @brief Get service by system.
 * @return an audio service, or NULL if XT-Audio was compiled without support for the given system.
 * @param system the desired system.
 *
 * This function may be called from any thread.
 * @see XtAudioIsWin32
 */

/**
 * @fn void XtAudioGetSampleAttributes(XtSample sample, XtAttributes* attributes)
 * @brief Get sample attributes for a specific sample type.
 * @param sample the sample type.
 * @param attributes (output) resulting sample attributes.
 *
 * This function may be called from any thread.
 */

/**
 * @fn void XtAudioInit(const char* id, void* window, XtTraceCallback trace, XtFatalCallback fatal)
 * @brief Initialize the XT-Audio library.
 * @param id the application id. Used to identify against sound servers such as JACK and PulseAudio. When NULL, "XT-Audio" is used.
 * @param window application main window handle. ASIO uses this to show modal control panels. When NULL, a dummy message window is used.
 * @param trace application-defined logging callback. When NULL, no logging is performed. Fatal errors are always written to stdout.
 * @param fatal application-defined fatal error handler to allow cleanup, may be NULL. This function must not return.
 *
 * This function may be called from any thread. The thread on which it is called becomes
 * the main thread, many other functions may only be called from the main thread. On Windows,
 * COM is initialized in STA mode by this call.
 */

/**
 * @fn XtSystem XtServiceGetSystem(const XtService* s)
 * @brief Get service system.
 * @return the system for the given service.
 * @param s the audio service.
 *
 * This function may be called from any thread.
 */

/**
 * @fn const char* XtServiceGetName(const XtService* s)
 * @brief Get service name.
 * @return a pointer to a statically allocated string containing the name of the given service.
 * @param s the audio service.
 *
 * This function may be called from any thread.
 */

/**
 * @fn XtCapabilities XtServiceGetCapabilities(const XtService* s)
 * @brief Get service capabilities.
 * @return the capabilities for the given service.
 * @param s the audio service.
 *
 * This function may be called from any thread.
 *
 * @see XtFormat
 * @see XtStreamCallback
 * @see XtStreamGetLatency
 */

/**
 * @fn XtError XtServiceGetDeviceCount(const XtService* s, int32_t* count)
 * @brief Gets number of devices in service.
 * @return 0 on success, a nonzero error code otherwise.
 * @param s the audio service.
 * @param count on success, receives the number of devices.
 *
 * This function may only be called from the main thread.
 *
 * @see XtServiceOpenDevice
 */

/**
 * @fn XtError XtServiceOpenDevice(const XtService* s, int32_t index, XtDevice** device)
 * @brief Open an audio device.
 * @return 0 on success, a nonzero error code otherwise.
 * @param s the audio service.
 * @param index the device index.
 * @param device on success, receives a pointer to the opened device. On error, *device is set to NULL.
 *
 * Use XtDeviceDestroy to clean up the device.
 *
 * This function may only be called from the main thread.
 * @see XtDeviceDestroy
 * @see XtServiceGetDeviceCount
 */

/**
 * @fn XtError XtServiceOpenDefaultDevice(const XtService* s, XtBool output, XtDevice** device)
 * @brief Open the default audio device.
 * @return 0 on success, a nonzero error code otherwise.
 * @param s the audio service.
 * @param output true to open the default output device, false to open the default input device.
 * @param device on success, receives a pointer to the opened device. On error or when no default device is present, *device is set to NULL.
 *
 * Use XtDeviceDestroy to clean up the device. It is NOT an error when no default device is present.
 *
 * This function may only be called from the main thread.
 * @see XtDeviceDestroy
 */

/**
 * @fn XtError XtServiceAggregateStream(const XtService* s, XtDevice** devices, const XtChannels* channels, const double* bufferSizes, int32_t count, const XtMix* mix, XtBool interleaved, XtDevice* master, XtStreamCallback streamCallback, XtXRunCallback xRunCallback, void* user, XtStream** stream);
 * @brief Opens an aggregate audio stream.
 * @return 0 on success, a nonzero error code otherwise.
 * @param s the audio service.
 * @param devices pointer to an array of [count] devices.
 * @param channels pointer to an array of [count] channel specifications.
 * @param bufferSizes pointer to an array of [count] buffer sizes in milliseconds.
 * @param count number of elements in the devices, channels, and bufferSizes arrays.
 * @param mix the mix format, to be used by all streams in the aggregated stream.
 * @param interleaved open the stream for interleaved access (true) or non-interleaved access (false).
 * @param master the master device, will be used for synchronization.
 * @param streamCallback the application-defined stream callback.
 * @param xRunCallback the application-defined xrun callback (may be NULL).
 * @param user user data passed to the stream callback (may be NULL).
 * @param stream on success, receives a pointer to the opened audio stream. On error, *stream will be NULL.
 *
 * Opens an aggregated audio stream on [count] devices. Each underlying stream is opened by 
 * calling XtDeviceOpenStream, passing in the Nth device, Nth buffer size and the combination
 * of the specified mix format and the Nth channel specification as the audio format.
 *
 * Aggregate streams use an intermediate buffer to keep underlying streams in sync.
 * The total latency overhead of the aggregate stream is bounded by the largest
 * buffer size of any of the underlying streams times a constant factor.
 *
 * Use XtDeviceGetBuffer to query supported buffer sizes.
 *
 * The resulting stream must be closed using XtStreamDestroy.
 *
 * When the requested interleaving mode is not supported by any device it will be emulated.
 *
 * This function may only be called from the main thread.
 *
 * @see XtStreamDestroy
 * @see XtDeviceOpenStream
 * @see XtDeviceSupportsFormat
 * @see XtDeviceSupportsAccess
 */

/**
 * @fn void XtDeviceDestroy(XtDevice* d)
 * @brief Destroys an audio device.
 * @param d the audio service.
 *
 * It is an error to destroy a device which still has open streams. It is ok to pass NULL.
 *
 * This function may only be called from the main thread.
 */

/**
 * @fn XtError XtDeviceShowControlPanel(XtDevice* d)
 * @brief Show the device specific control panel.
 * @return 0 on success, a nonzero error code otherwise.
 * @param d the audio device.
 *
 * This method currently has an effect on ASIO devices only.
 * All others succeed and do nothing.
 *
 * This function may only be called from the main thread.
 */

/**
 * @fn XtSystem XtDeviceGetSystem(const XtDevice* d)
 * @brief Get device system.
 * @return the system for the given device.
 * @param d the audio device.
 *
 * This function may be called from any thread.
 */

/**
 * @fn XtError XtDeviceGetMix(const XtDevice* d, XtMix** mix)
 * @brief Gets the device's current mix format.
 * @return 0 on success, a nonzero error code otherwise.
 * @param d the audio device.
 * @param mix on success, receives a pointer to a newly allocated XtMix. Use XtAudioFree to free the returned value. On error, or when no mix format is present, *mix will be NULL.
 *
 * It is NOT an error when a device has no current or default mix format.
 * The mix format may be used as a starting point to query for supported
 * audio formats (see XtDeviceSupportsFormat).
 *
 * This function may only be called from the main thread.
 * @see XtDeviceSupportsFormat
 */

/**
 * @fn XtError XtDeviceGetName(const XtDevice* d, char** name)
 * @brief Gets the device's name.
 * @return 0 on success, a nonzero error code otherwise.
 * @param d the audio device.
 * @param name on success, receives a pointer to a dynamically allocated string. Use XtAudioFree to free the returned string. On error *name will be NULL.
 *
 * This function may only be called from the main thread.
 */

/**
 * @fn XtError XtDeviceGetChannelCount(const XtDevice* d, XtBool output, int32_t* count)
 * @brief Gets the maximum number of channels supported by the device.
 * @return 0 on success, a nonzero error code otherwise.
 * @param d the audio device.
 * @param output true to query output channels, false to query input channels.
 * @param count on success, receives the maximum channel count.
 *
 * The channel count represents the maximum number of channels representable by
 * the current device. This value dictates the possible values of the audio
 * format's channel masks only, it does not indicate that the device actually
 * supports streams with the number of channels returned by this method.
 *
 * This function may only be called from the main thread.
 * @see XtFormat
 * @see XtDeviceGetChannelName
 */

/**
 * @fn XtError XtDeviceGetBuffer(const XtDevice* d, const XtFormat* format, XtBuffer* buffer)
 * @brief Gets the buffer size limits supported by the device.
 * @return 0 on success, a nonzero error code otherwise.
 * @param d the audio device.
 * @param format the audio format to test buffer limits for.
 * @param buffer on success, buffer receives the buffer size limits for the given format.
 *
 * The given format must be supported by the device, see XtDeviceSupportsFormat.
 *
 * This function may only be called from the main thread.
 * @see XtDeviceOpenStream
 * @see XtDeviceSupportsFormat
 * @see XtServiceAggregateStream
 */

/**
 * @fn XtError XtDeviceSupportsFormat(const XtDevice* d, const XtFormat* format, XtBool* supports)
 * @brief Indicates whether an audio format is supported by the device.
 * @return 0 on success, a nonzero error code otherwise.
 * @param d the audio device.
 * @param format the audio format to test support for.
 * @param supports on success, indicates whether the format is supported.
 *
 * This function may only be called from the main thread.
 * @see XtDeviceOpenStream
 * @see XtDeviceGetBuffer
 * @see XtServiceAggregateStream
 */

/**
 * @fn XtError XtDeviceSupportsAccess(const XtDevice* d, XtBool interleaved, XtBool* supports)
 * @brief Indicates whether the device supports the specified access mode.
 * @return 0 on success, a nonzero error code otherwise.
 * @param d the audio device.
 * @param interleaved the desired access mode. True for interleaved, false for non-interleaved.
 * @param supports on success, indicates whether the access mode is supported.
 *
 * When opening a stream using an access mode that is not supported by the device, the
 * access mode will be emulated.
 *
 * This function may only be called from the main thread.
 * @see XtDeviceOpenStream
 * @see XtServiceAggregateStream
 */

/**
 * @fn XtError XtDeviceGetChannelName(const XtDevice* d, XtBool output, int32_t index, char** name)
 * @brief Gets the name of a specific input/output channel.
 * @return 0 on success, a nonzero error code otherwise.
 * @param d the audio device.
 * @param output true for output channels, false for input channels.
 * @param index the channel index.
 * @param name on success, receives a pointer to a dynamically allocated string. Use XtAudioFree to free the returned string. On error *name will be NULL.
 *
 * This function may only be called from the main thread.
 *
 * @see XtDeviceGetChannelCount
 */

/**
 * @fn XtError XtDeviceOpenStream(XtDevice* d, const XtFormat* format, XtBool interleaved, double bufferSize, XtStreamCallback streamCallback, XtXRunCallback xRunCallback, void* user, XtStream** stream)
 * @brief Opens an audio stream on the given device.
 * @return 0 on success, a nonzero error code otherwise.
 * @param d the audio device.
 * @param format the audio format (must be supported).
 * @param interleaved open the stream for interleaved access (true) or non-interleaved access (false).
 * @param bufferSize the desired buffer size in milliseconds (will be truncated to the supported range).
 * @param streamCallback the application-defined stream callback.
 * @param xRunCallback the application-defined xrun callback (may be NULL).
 * @param user user data passed to the stream callback (may be NULL).
 * @param stream on success, receives a pointer to the opened audio stream. On error, *stream will be NULL.
 *
 * Use XtDeviceGetBuffer to query supported buffer sizes.
 *
 * The resulting stream must be closed using XtStreamDestroy.
 *
 * When the requested interleaving mode is not supported by the device it will be emulated.
 *
 * This function may only be called from the main thread.
 *
 * @see XtStreamDestroy
 * @see XtDeviceSupportsFormat
 * @see XtDeviceSupportsAccess
 * @see XtServiceAggregateStream
 */

/**
 * @fn void XtStreamDestroy(XtStream* s)
 * @brief Destroys an audio stream.
 * @param s the audio stream.
 *
 * It is ok to pass NULL and to destroy a running stream (it will be stopped first).
 *
 * This function may only be called from the main thread.
 */

/**
 * @fn XtError XtStreamStop(XtStream* s)
 * @brief Stops an audio stream.
 * @return 0 on success, a nonzero error code otherwise.
 * @param s the audio stream.
 *
 * This function may only be called from the main thread.
 *
 * @see XtStreamStart
 */

/**
 * @fn XtError XtStreamStart(XtStream* s)
 * @brief Starts an audio stream.
 * @return 0 on success, a nonzero error code otherwise.
 * @param s the audio stream.
 *
 * When the stream is running the application-defined stream callback will be invoked whenever audio data is needed or available.
 *
 * This function may only be called from the main thread.
 *
 * @see XtStreamStop
 */

/**
 * @fn XtSystem XtStreamGetSystem(const XtStream* s)
 * @brief Get stream system.
 * @return the system for the given stream.
 * @param s the audio stream.
 *
 * This function may be called from any thread.
 */

/**
 * @fn const XtFormat* XtStreamGetFormat(const XtStream* s)
 * @brief Get stream format.
 * @return the audio format used to open the stream.
 * @param s the audio stream.
 *
 * Note: for aggregate streams this format will contain the total number of input and output channels 
 * passed to XtServiceAggregateStream. Channel masks for aggregate streams will always be 0.
 *
 * This function may be called from any thread.
 *
 * @see XtDeviceOpenStream
 * @see XtServiceAggregateStream
 */

/**
 * @fn XtBool XtStreamIsInterleaved(const XtStream* s)
 * @brief Indicates whether the stream is interleaved.
 * @return the access mode used to open the stream.
 * @param s the audio stream.
 *
 * This function may be called from any thread.
 *
 * @see XtDeviceOpenStream
 * @see XtServiceAggregateStream
 */

/**
 * @fn XtError XtStreamGetFrames(const XtStream* s, int32_t* frames)
 * @brief Get maximum stream buffer size.
 * @return The maximum buffer size for the given stream.
 * @param s the audio stream.
 * @param frames on success, reveices the stream buffer size in frames.
 *
 * This value is constant for the lifetime of the stream. It may be used
 * to pre-allocate any intermediate buffers the application may need.
 *
 * This function may be called from any thread (to allow invocation from the stream callback).
 */

/**
 * @fn XtError XtStreamGetLatency(const XtStream* s, XtLatency* latency)
 * @brief Get the end-to-end latency, if supported by the system.
 * @return The current latencies for the given stream.
 * @param s the audio stream.
 * @param latency on success, receives the current input/output latency in milliseconds. When the service does not support latency information, latency->input and latency->output will be 0.
 *
 * This value may change during the lifetime of the stream.
 * For aggregate streams, the maximum input and output latencies of any underlying stream, plus the latency of the aggregation buffer is reported.
 * When any of the underlying streams does not support latency info, the latency of the entire aggregated stream is reported as unknown.
 *
 * This function may be called from any thread (to allow invocation from the stream callback).
 *
 * @see XtServiceGetCapabilities
 */
